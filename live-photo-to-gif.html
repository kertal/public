<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Live Photo → GIF Converter</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0e0e10;
    --surface: #1a1a2e;
    --surface2: #22223a;
    --accent: #6c63ff;
    --accent-hover: #5a52e0;
    --text: #e8e8f0;
    --text-dim: #9090a8;
    --border: #2a2a44;
    --success: #4ecdc4;
    --danger: #ff6b6b;
    --warn: #f0c040;
    --radius: 12px;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 24px 16px;
  }

  h1 { font-size: 1.6rem; font-weight: 700; margin-bottom: 4px; text-align: center; }
  .subtitle { color: var(--text-dim); font-size: 0.9rem; margin-bottom: 28px; text-align: center; max-width: 540px; line-height: 1.5; }

  .app { width: 100%; max-width: 720px; display: flex; flex-direction: column; gap: 20px; }

  /* Drop zone */
  .drop-zone {
    border: 2px dashed var(--border);
    border-radius: var(--radius);
    padding: 36px 24px;
    text-align: center;
    cursor: pointer;
    transition: border-color 0.2s, background 0.2s;
    background: var(--surface);
  }
  .drop-zone:hover, .drop-zone.dragover { border-color: var(--accent); background: var(--surface2); }
  .drop-zone p { color: var(--text-dim); margin-top: 8px; font-size: 0.85rem; line-height: 1.5; }
  .drop-zone .icon { font-size: 2.4rem; margin-bottom: 8px; }
  .drop-zone .browse {
    display: inline-block; margin-top: 14px; padding: 8px 20px;
    background: var(--accent); color: #fff; border: none; border-radius: 8px;
    font-size: 0.9rem; cursor: pointer; transition: background 0.2s;
  }
  .drop-zone .browse:hover { background: var(--accent-hover); }

  /* How-to guide */
  .guide {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); overflow: hidden;
  }
  .guide-header {
    padding: 16px 20px; cursor: pointer; display: flex;
    justify-content: space-between; align-items: center;
    user-select: none;
  }
  .guide-header h2 { font-size: 0.95rem; font-weight: 600; }
  .guide-header .arrow { transition: transform 0.2s; color: var(--text-dim); font-size: 0.8rem; }
  .guide.open .guide-header .arrow { transform: rotate(180deg); }
  .guide-body { display: none; padding: 0 20px 20px; }
  .guide.open .guide-body { display: block; }

  .method-tabs {
    display: flex; gap: 0; margin-bottom: 16px;
    border-bottom: 2px solid var(--border);
  }
  .method-tab {
    padding: 10px 18px; font-size: 0.85rem; font-weight: 600;
    color: var(--text-dim); background: none; border: none;
    cursor: pointer; border-bottom: 2px solid transparent;
    margin-bottom: -2px; transition: color 0.2s, border-color 0.2s;
  }
  .method-tab:hover { color: var(--text); }
  .method-tab.active { color: var(--accent); border-bottom-color: var(--accent); }

  .method-content { display: none; }
  .method-content.active { display: block; }

  .step-list { list-style: none; padding: 0; counter-reset: step; }
  .step-list li {
    counter-increment: step; position: relative;
    padding: 10px 0 10px 36px; font-size: 0.85rem;
    line-height: 1.6; color: var(--text-dim);
    border-left: 2px solid var(--border); margin-left: 12px;
  }
  .step-list li:last-child { border-left-color: transparent; }
  .step-list li::before {
    content: counter(step); position: absolute; left: -11px; top: 8px;
    width: 22px; height: 22px; border-radius: 50%;
    background: var(--accent); color: #fff; font-size: 0.72rem;
    font-weight: 700; display: flex; align-items: center; justify-content: center;
  }
  .step-list li strong { color: var(--text); }

  .tip-box {
    margin-top: 14px; padding: 10px 14px; border-radius: 8px;
    background: rgba(78,205,196,0.08); border: 1px solid rgba(78,205,196,0.2);
    font-size: 0.82rem; line-height: 1.6; color: var(--success);
  }

  /* Status banner */
  .status-banner {
    padding: 12px 16px; border-radius: 8px; font-size: 0.85rem; line-height: 1.5;
    display: none;
  }
  .status-banner.active { display: block; }
  .status-banner.warn { background: rgba(240,192,64,0.1); border: 1px solid rgba(240,192,64,0.3); color: var(--warn); }
  .status-banner.error { background: rgba(255,107,107,0.1); border: 1px solid rgba(255,107,107,0.3); color: var(--danger); }

  /* Card panel */
  .card {
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 20px;
  }
  .card h2 { font-size: 1rem; font-weight: 600; margin-bottom: 14px; }

  /* Video preview */
  .preview-wrap {
    position: relative; width: 100%; border-radius: 8px;
    overflow: hidden; background: #000;
    display: flex; align-items: center; justify-content: center;
  }
  .preview-wrap video { max-width: 100%; max-height: 420px; display: block; }

  /* Trim controls */
  .trim-section { display: flex; flex-direction: column; gap: 12px; }

  .range-track {
    position: relative; height: 48px; background: var(--surface2);
    border-radius: 8px; overflow: hidden; cursor: pointer;
    user-select: none; touch-action: none;
  }
  .range-track canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
  .range-overlay {
    position: absolute; top: 0; height: 100%;
    background: rgba(108,99,255,0.25);
    border-left: 3px solid var(--accent); border-right: 3px solid var(--accent);
    pointer-events: none;
  }
  .range-handle {
    position: absolute; top: 0; width: 14px; height: 100%;
    cursor: ew-resize; z-index: 2;
  }
  .range-handle::after {
    content: ''; position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 4px; height: 24px; background: #fff;
    border-radius: 2px; box-shadow: 0 0 4px rgba(0,0,0,0.5);
  }
  .range-handle.left { left: 0; }
  .range-handle.right { right: 0; }

  .playhead-line {
    position: absolute; top: 0; width: 2px; height: 100%;
    background: #fff; pointer-events: none; z-index: 3; display: none;
  }

  .trim-info { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px; }
  .trim-info span { font-size: 0.85rem; color: var(--text-dim); font-variant-numeric: tabular-nums; }
  .trim-info .duration { color: var(--success); font-weight: 600; }

  /* Settings row */
  .settings-row { display: flex; gap: 12px; flex-wrap: wrap; }
  .setting { flex: 1; min-width: 120px; display: flex; flex-direction: column; gap: 4px; }
  .setting label { font-size: 0.78rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.05em; }
  .setting select, .setting input {
    padding: 8px 10px; background: var(--surface2); border: 1px solid var(--border);
    border-radius: 6px; color: var(--text); font-size: 0.9rem; outline: none;
  }
  .setting select:focus, .setting input:focus { border-color: var(--accent); }

  /* Buttons */
  .btn-row { display: flex; gap: 10px; flex-wrap: wrap; }
  .btn {
    padding: 10px 24px; border: none; border-radius: 8px;
    font-size: 0.95rem; font-weight: 600; cursor: pointer;
    transition: background 0.2s, opacity 0.2s;
    display: inline-flex; align-items: center; gap: 6px;
  }
  .btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .btn-primary { background: var(--accent); color: #fff; flex: 1; justify-content: center; }
  .btn-primary:hover:not(:disabled) { background: var(--accent-hover); }
  .btn-secondary { background: var(--surface2); color: var(--text); border: 1px solid var(--border); }
  .btn-secondary:hover:not(:disabled) { background: var(--border); }
  .btn-download { background: var(--success); color: #000; flex: 1; justify-content: center; }
  .btn-download:hover { background: #3dbdb5; }

  /* Progress */
  .progress-wrap { display: none; flex-direction: column; gap: 6px; }
  .progress-wrap.active { display: flex; }
  .progress-bar-outer { height: 8px; background: var(--surface2); border-radius: 4px; overflow: hidden; }
  .progress-bar-inner { height: 100%; width: 0%; background: var(--accent); border-radius: 4px; transition: width 0.15s; }
  .progress-text { font-size: 0.82rem; color: var(--text-dim); text-align: center; }

  /* Result */
  .result-wrap { display: none; flex-direction: column; gap: 14px; align-items: center; }
  .result-wrap.active { display: flex; }
  .result-wrap img { max-width: 100%; border-radius: 8px; border: 1px solid var(--border); }
  .result-meta { font-size: 0.85rem; color: var(--text-dim); text-align: center; }

  .hidden { display: none !important; }

  @media (max-width: 500px) {
    h1 { font-size: 1.3rem; }
    .drop-zone { padding: 28px 16px; }
    .card { padding: 14px; }
    .method-tab { padding: 8px 12px; font-size: 0.8rem; }
  }
</style>
</head>
<body>

<h1>Live Photo &rarr; GIF</h1>
<p class="subtitle">Convert the video from an iOS Live Photo into an animated GIF &mdash; entirely in your browser, nothing uploaded.</p>

<div class="app">

  <!-- Drop Zone -->
  <div class="drop-zone" id="dropZone">
    <div class="icon">&#9861;</div>
    <div><strong>Drop the video from your Live Photo here</strong></div>
    <p>Accepts <strong>.MOV</strong> or <strong>.MP4</strong> files</p>
    <button class="browse" id="browseBtn">Choose Video File</button>
    <input type="file" id="fileInput" accept=".mov,.mp4,.m4v,video/*" hidden>
  </div>

  <!-- How-to guide -->
  <div class="guide open" id="guide">
    <div class="guide-header" id="guideToggle">
      <h2>How to get the video from a Live Photo</h2>
      <span class="arrow">&#9660;</span>
    </div>
    <div class="guide-body">
      <p style="font-size:0.83rem; color:var(--text-dim); margin-bottom:14px; line-height:1.5;">
        iOS stores a Live Photo as two separate files: a still image (.HEIC) and a short video (.MOV).
        Browsers can't read the .HEIC directly &mdash; you need the .MOV video companion. Here's how to get it:
      </p>
      <div class="method-tabs">
        <button class="method-tab active" data-method="iphone">iPhone</button>
        <button class="method-tab" data-method="mac">Mac</button>
        <button class="method-tab" data-method="quick">Quickest Way</button>
      </div>

      <div class="method-content active" data-method="iphone">
        <ol class="step-list">
          <li>Open the <strong>Photos</strong> app and find your Live Photo</li>
          <li>Tap the <strong>&middot;&middot;&middot;</strong> menu (top right) or long-press the photo</li>
          <li>Tap <strong>Save as Video</strong></li>
          <li>The video now appears in your Recents &mdash; share or save it to Files</li>
          <li>Open this page in Safari and <strong>Choose Video File</strong> above</li>
        </ol>
        <div class="tip-box">
          Don't see "Save as Video"? Make sure <strong>Live</strong> is turned on for that photo (not set to Long Exposure or Loop).
        </div>
      </div>

      <div class="method-content" data-method="mac">
        <ol class="step-list">
          <li>Open <strong>Photos</strong> on your Mac and select the Live Photo</li>
          <li>Go to <strong>File &rarr; Export &rarr; Export Unmodified Original</strong></li>
          <li>This saves two files: a <strong>.HEIC</strong> (still image) and a <strong>.MOV</strong> (video)</li>
          <li>Drag the <strong>.MOV file</strong> onto the drop zone above</li>
        </ol>
        <div class="tip-box">
          You can also drag the Live Photo directly from Photos into Finder first, then drag the .MOV file here.
        </div>
      </div>

      <div class="method-content" data-method="quick">
        <ol class="step-list">
          <li><strong>AirDrop</strong> the Live Photo from iPhone to your Mac</li>
          <li>It arrives as two files: <code>.HEIC</code> + <code>.MOV</code></li>
          <li>Drag the <strong>.MOV</strong> here</li>
        </ol>
        <div class="tip-box">
          This is the fastest way if you have a Mac nearby. The .MOV file is the exact original video from the Live Photo.
        </div>
      </div>
    </div>
  </div>

  <!-- Status banner -->
  <div class="status-banner" id="statusBanner"></div>

  <!-- Editor Panel -->
  <div class="card hidden" id="editorPanel">
    <h2>Preview &amp; Trim</h2>

    <div class="preview-wrap">
      <video id="videoEl" muted playsinline></video>
    </div>

    <div class="trim-section" style="margin-top: 14px;">
      <div class="range-track" id="rangeTrack">
        <canvas id="thumbCanvas"></canvas>
        <div class="range-overlay" id="rangeOverlay"></div>
        <div class="range-handle left" id="handleLeft"></div>
        <div class="range-handle right" id="handleRight"></div>
        <div class="playhead-line" id="playhead"></div>
      </div>

      <div class="trim-info">
        <span>Start: <strong id="trimStartLabel">0.00s</strong></span>
        <span class="duration">Duration: <strong id="trimDurLabel">0.00s</strong></span>
        <span>End: <strong id="trimEndLabel">0.00s</strong></span>
      </div>

      <div class="btn-row" style="margin-top: 2px;">
        <button class="btn btn-secondary" id="playTrimBtn">&#9654; Preview Trim</button>
      </div>
    </div>

    <div style="margin-top: 16px;">
      <h2>Settings</h2>
      <div class="settings-row" style="margin-top: 8px;">
        <div class="setting">
          <label>FPS</label>
          <select id="fpsSelect">
            <option value="10">10</option>
            <option value="15" selected>15</option>
            <option value="20">20</option>
            <option value="25">25</option>
            <option value="30">30</option>
          </select>
        </div>
        <div class="setting">
          <label>Max Width (px)</label>
          <input type="number" id="widthInput" value="480" min="100" max="1920" step="10">
        </div>
        <div class="setting">
          <label>Quality</label>
          <select id="qualitySelect">
            <option value="5">Low (smaller file)</option>
            <option value="10" selected>Medium</option>
            <option value="15">High</option>
            <option value="20">Best (larger file)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="btn-row" style="margin-top: 18px;">
      <button class="btn btn-primary" id="convertBtn">Convert to GIF</button>
    </div>

    <div class="progress-wrap" id="progressWrap" style="margin-top: 14px;">
      <div class="progress-bar-outer"><div class="progress-bar-inner" id="progressBar"></div></div>
      <div class="progress-text" id="progressText">Extracting frames...</div>
    </div>
  </div>

  <!-- Result Panel -->
  <div class="card hidden" id="resultPanel">
    <h2>Your GIF</h2>
    <div class="result-wrap active">
      <img id="resultImg" alt="Converted GIF">
      <div class="result-meta" id="resultMeta"></div>
      <div class="btn-row" style="width:100%;">
        <button class="btn btn-download" id="downloadBtn">&#11015; Download GIF</button>
        <button class="btn btn-secondary" id="resetBtn">New Live Photo</button>
      </div>
    </div>
  </div>

</div>

<script>
// ============================================================
//  GIF Encoder — pure JS, GIF89a with LZW compression
// ============================================================
class GIFEncoder {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.frames = [];
    this.data = [];
  }

  static quantize(pixels, maxColors = 256) {
    const colorMap = new Map();
    const step = Math.max(1, Math.floor(pixels.length / (4 * 50000)));
    for (let i = 0; i < pixels.length; i += 4 * step) {
      const r = pixels[i] & 0xF8, g = pixels[i+1] & 0xFC, b = pixels[i+2] & 0xF8;
      const key = (r << 16) | (g << 8) | b;
      colorMap.set(key, (colorMap.get(key) || 0) + 1);
    }

    let boxes = [Array.from(colorMap.entries()).map(([k, c]) => [((k>>16)&0xFF), ((k>>8)&0xFF), (k&0xFF), c])];
    while (boxes.length < maxColors) {
      let bestIdx = 0, bestRange = -1, bestCh = 0;
      for (let i = 0; i < boxes.length; i++) {
        const box = boxes[i]; if (box.length < 2) continue;
        for (let ch = 0; ch < 3; ch++) {
          let mn = 255, mx = 0;
          for (const c of box) { mn = Math.min(mn, c[ch]); mx = Math.max(mx, c[ch]); }
          if (mx - mn > bestRange) { bestRange = mx - mn; bestIdx = i; bestCh = ch; }
        }
      }
      if (bestRange <= 0) break;
      const box = boxes[bestIdx];
      box.sort((a, b) => a[bestCh] - b[bestCh]);
      const mid = box.length >> 1;
      boxes.splice(bestIdx, 1, box.slice(0, mid), box.slice(mid));
    }

    const palette = [];
    for (const box of boxes) {
      let rS = 0, gS = 0, bS = 0, t = 0;
      for (const [r, g, b, c] of box) { rS += r*c; gS += g*c; bS += b*c; t += c; }
      palette.push(t === 0 ? [0,0,0] : [Math.round(rS/t), Math.round(gS/t), Math.round(bS/t)]);
    }
    let bits = 1;
    while ((1 << bits) < palette.length) bits++;
    while (palette.length < (1 << bits)) palette.push([0,0,0]);
    return { palette, bits };
  }

  static mapPixels(pixels, w, h, palette) {
    const n = w * h, indices = new Uint8Array(n), cache = new Map();
    const findClosest = (r, g, b) => {
      const key = ((r&0xFC)<<16)|((g&0xFC)<<8)|(b&0xFC);
      if (cache.has(key)) return cache.get(key);
      let best = Infinity, bi = 0;
      for (let i = 0; i < palette.length; i++) {
        const dr = r-palette[i][0], dg = g-palette[i][1], db = b-palette[i][2], d = dr*dr+dg*dg+db*db;
        if (d < best) { best = d; bi = i; }
      }
      cache.set(key, bi); return bi;
    };
    const eR = new Float32Array(n), eG = new Float32Array(n), eB = new Float32Array(n);
    for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
      const i = y*w+x, p = i*4;
      const r = Math.max(0, Math.min(255, pixels[p]+eR[i]));
      const g = Math.max(0, Math.min(255, pixels[p+1]+eG[i]));
      const b = Math.max(0, Math.min(255, pixels[p+2]+eB[i]));
      const ci = findClosest(r, g, b); indices[i] = ci;
      const dr = r-palette[ci][0], dg = g-palette[ci][1], db = b-palette[ci][2];
      if (x+1<w) { eR[i+1]+=dr*7/16; eG[i+1]+=dg*7/16; eB[i+1]+=db*7/16; }
      if (y+1<h) {
        if (x>0) { eR[i+w-1]+=dr*3/16; eG[i+w-1]+=dg*3/16; eB[i+w-1]+=db*3/16; }
        eR[i+w]+=dr*5/16; eG[i+w]+=dg*5/16; eB[i+w]+=db*5/16;
        if (x+1<w) { eR[i+w+1]+=dr*1/16; eG[i+w+1]+=dg*1/16; eB[i+w+1]+=db*1/16; }
      }
    }
    return indices;
  }

  addFrame(imageData, delay = 100) { this.frames.push({ data: imageData, delay }); }

  static lzwEncode(indices, minCodeSize) {
    const clearCode = 1 << minCodeSize, eoiCode = clearCode + 1, output = [];
    let codeSize = minCodeSize + 1, nextCode = eoiCode + 1;
    let dict = new Map();
    const initDict = () => { dict.clear(); for (let i = 0; i < clearCode; i++) dict.set(String(i), i); codeSize = minCodeSize + 1; nextCode = eoiCode + 1; };
    let buffer = 0, bufBits = 0;
    const emit = (code) => { buffer |= (code << bufBits); bufBits += codeSize; while (bufBits >= 8) { output.push(buffer & 0xFF); buffer >>= 8; bufBits -= 8; } };
    initDict(); emit(clearCode);
    let w = String(indices[0]);
    for (let i = 1; i < indices.length; i++) {
      const k = String(indices[i]), wk = w + ',' + k;
      if (dict.has(wk)) { w = wk; }
      else { emit(dict.get(w)); if (nextCode < 4096) { dict.set(wk, nextCode++); if (nextCode > (1<<codeSize) && codeSize < 12) codeSize++; } else { emit(clearCode); initDict(); } w = k; }
    }
    emit(dict.get(w)); emit(eoiCode);
    if (bufBits > 0) output.push(buffer & 0xFF);
    return output;
  }

  encode() {
    const out = this.data, w = this.width, h = this.height;
    const { palette, bits: colorBits } = GIFEncoder.quantize(this.frames[0].data);
    const tableSize = 1 << colorBits;
    out.push(0x47,0x49,0x46,0x38,0x39,0x61); // GIF89a
    out.push(w&0xFF,(w>>8)&0xFF,h&0xFF,(h>>8)&0xFF);
    out.push(0x80|((colorBits-1)<<4)|(colorBits-1), 0, 0);
    for (let i = 0; i < tableSize; i++) out.push(palette[i][0], palette[i][1], palette[i][2]);
    // Netscape loop
    out.push(0x21,0xFF,0x0B, 0x4E,0x45,0x54,0x53,0x43,0x41,0x50,0x45,0x32,0x2E,0x30, 0x03,0x01,0x00,0x00,0x00);
    for (const frame of this.frames) {
      const indices = GIFEncoder.mapPixels(frame.data, w, h, palette);
      out.push(0x21,0xF9,0x04, 0x00);
      const d = Math.round(frame.delay / 10);
      out.push(d&0xFF,(d>>8)&0xFF, 0x00, 0x00);
      out.push(0x2C, 0,0,0,0, w&0xFF,(w>>8)&0xFF, h&0xFF,(h>>8)&0xFF, 0x00);
      const mcs = Math.max(2, colorBits); out.push(mcs);
      const lzw = GIFEncoder.lzwEncode(indices, mcs);
      let off = 0;
      while (off < lzw.length) { const sz = Math.min(255, lzw.length - off); out.push(sz); for (let i = 0; i < sz; i++) out.push(lzw[off++]); }
      out.push(0x00);
    }
    out.push(0x3B);
    return new Uint8Array(out);
  }
}


// ============================================================
//  App Logic
// ============================================================
(() => {
  const $ = s => document.querySelector(s);
  const dropZone      = $('#dropZone');
  const browseBtn     = $('#browseBtn');
  const fileInput     = $('#fileInput');
  const guide         = $('#guide');
  const guideToggle   = $('#guideToggle');
  const statusBanner  = $('#statusBanner');
  const editorPanel   = $('#editorPanel');
  const resultPanel   = $('#resultPanel');
  const videoEl       = $('#videoEl');
  const rangeTrack    = $('#rangeTrack');
  const thumbCanvas   = $('#thumbCanvas');
  const rangeOverlay  = $('#rangeOverlay');
  const handleLeft    = $('#handleLeft');
  const handleRight   = $('#handleRight');
  const playhead      = $('#playhead');
  const trimStartLbl  = $('#trimStartLabel');
  const trimEndLbl    = $('#trimEndLabel');
  const trimDurLbl    = $('#trimDurLabel');
  const playTrimBtn   = $('#playTrimBtn');
  const fpsSelect     = $('#fpsSelect');
  const widthInput    = $('#widthInput');
  const convertBtn    = $('#convertBtn');
  const progressWrap  = $('#progressWrap');
  const progressBar   = $('#progressBar');
  const progressText  = $('#progressText');
  const resultImg     = $('#resultImg');
  const resultMeta    = $('#resultMeta');
  const downloadBtn   = $('#downloadBtn');
  const resetBtn      = $('#resetBtn');

  let trimStart = 0, trimEnd = 1;
  let duration = 0;
  let videoURL = null;
  let gifBlob = null;
  let dragging = null;
  let isConverting = false;

  // ---- Guide tabs ----
  guideToggle.addEventListener('click', () => guide.classList.toggle('open'));

  document.querySelectorAll('.method-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.method-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.method-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.querySelector(`.method-content[data-method="${tab.dataset.method}"]`).classList.add('active');
    });
  });

  function showStatus(msg, type = 'warn') {
    statusBanner.innerHTML = msg;
    statusBanner.className = 'status-banner active ' + type;
  }
  function hideStatus() { statusBanner.className = 'status-banner'; }

  // ---- File handling ----
  browseBtn.addEventListener('click', e => { e.stopPropagation(); fileInput.click(); });
  dropZone.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => { if (fileInput.files[0]) handleFile(fileInput.files[0]); });

  dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
  dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
  dropZone.addEventListener('drop', e => {
    e.preventDefault();
    dropZone.classList.remove('dragover');
    if (!e.dataTransfer.files.length) return;

    const files = Array.from(e.dataTransfer.files);
    // If multiple files, look for a video among them (user might have dropped HEIC + MOV pair)
    const video = files.find(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return ['mov','mp4','m4v'].includes(ext) || f.type.startsWith('video/');
    });

    if (video) {
      hideStatus();
      handleFile(video);
      return;
    }

    // Check if they dropped a HEIC
    const heic = files.find(f => {
      const ext = f.name.split('.').pop().toLowerCase();
      return ['heic','heif'].includes(ext) || f.type === 'image/heic' || f.type === 'image/heif';
    });

    if (heic) {
      showStatus(
        '<strong>That\'s the still image (.HEIC), not the video.</strong><br>' +
        'iOS Live Photos are stored as two separate files. ' +
        'Browsers can\'t extract the video from the .HEIC &mdash; you need the .MOV companion file.<br><br>' +
        'See the instructions below for how to get it.',
        'warn'
      );
      guide.classList.add('open');
      return;
    }

    // Unknown file
    showStatus('This file type isn\'t supported. Drop a .MOV or .MP4 video file.', 'error');
  });

  function handleFile(file) {
    const ext = file.name.split('.').pop().toLowerCase();
    if (!['mov','mp4','m4v'].includes(ext) && !file.type.startsWith('video/')) {
      showStatus('This file type isn\'t supported. Drop a .MOV or .MP4 video file.', 'error');
      return;
    }
    hideStatus();
    if (videoURL) URL.revokeObjectURL(videoURL);
    videoURL = URL.createObjectURL(file);
    loadVideoIntoEditor(videoURL);
  }

  function loadVideoIntoEditor(url) {
    videoEl.src = url;
    videoEl.addEventListener('loadedmetadata', () => {
      duration = videoEl.duration;
      trimStart = 0;
      trimEnd = 1;
      updateTrimUI();
      generateThumbnails();
      dropZone.classList.add('hidden');
      guide.classList.add('hidden');
      editorPanel.classList.remove('hidden');
      resultPanel.classList.add('hidden');
    }, { once: true });
    videoEl.addEventListener('error', () => {
      showStatus('Could not play this video. The codec may not be supported by your browser. Try Safari for HEVC videos.', 'error');
    }, { once: true });
  }

  // ---- Thumbnail strip ----
  function generateThumbnails() {
    const rect = rangeTrack.getBoundingClientRect();
    const cw = rect.width * devicePixelRatio;
    const ch = rect.height * devicePixelRatio;
    thumbCanvas.width = cw; thumbCanvas.height = ch;
    thumbCanvas.style.width = rect.width + 'px';
    thumbCanvas.style.height = rect.height + 'px';
    const ctx = thumbCanvas.getContext('2d');
    const numThumbs = Math.min(Math.ceil(rect.width / 48), 30);

    const tv = document.createElement('video');
    tv.muted = true; tv.src = videoURL; tv.preload = 'auto';
    tv.addEventListener('loadedmetadata', () => {
      const draw = (i) => {
        if (i >= numThumbs) return;
        tv.currentTime = (i / numThumbs) * tv.duration;
        tv.addEventListener('seeked', () => {
          const tw = cw / numThumbs;
          ctx.drawImage(tv, i * tw, 0, tw, ch);
          draw(i + 1);
        }, { once: true });
      };
      draw(0);
    });
  }

  // ---- Trim range ----
  function updateTrimUI() {
    rangeOverlay.style.left = (trimStart * 100) + '%';
    rangeOverlay.style.width = ((trimEnd - trimStart) * 100) + '%';
    handleLeft.style.left = (trimStart * 100) + '%';
    handleRight.style.left = (trimEnd * 100) + '%';
    handleRight.style.transform = 'translateX(-100%)';
    const ts = trimStart * duration, te = trimEnd * duration;
    trimStartLbl.textContent = ts.toFixed(2) + 's';
    trimEndLbl.textContent = te.toFixed(2) + 's';
    trimDurLbl.textContent = (te - ts).toFixed(2) + 's';
  }

  function getFraction(e) {
    const rect = rangeTrack.getBoundingClientRect();
    const cx = e.touches ? e.touches[0].clientX : e.clientX;
    return Math.max(0, Math.min(1, (cx - rect.left) / rect.width));
  }

  handleLeft.addEventListener('mousedown', e => { e.stopPropagation(); dragging = 'left'; });
  handleRight.addEventListener('mousedown', e => { e.stopPropagation(); dragging = 'right'; });
  handleLeft.addEventListener('touchstart', e => { e.stopPropagation(); dragging = 'left'; }, { passive: true });
  handleRight.addEventListener('touchstart', e => { e.stopPropagation(); dragging = 'right'; }, { passive: true });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const f = getFraction(e);
    if (dragging === 'left') trimStart = Math.min(f, trimEnd - 0.01);
    else trimEnd = Math.max(f, trimStart + 0.01);
    updateTrimUI();
  });
  document.addEventListener('mouseup', () => { dragging = null; });
  document.addEventListener('touchmove', e => {
    if (!dragging) return;
    const f = getFraction(e);
    if (dragging === 'left') trimStart = Math.min(f, trimEnd - 0.01);
    else trimEnd = Math.max(f, trimStart + 0.01);
    updateTrimUI();
  }, { passive: true });
  document.addEventListener('touchend', () => { dragging = null; });

  rangeTrack.addEventListener('click', e => {
    if (e.target === handleLeft || e.target === handleRight) return;
    videoEl.currentTime = getFraction(e) * duration;
  });

  // ---- Preview trim ----
  playTrimBtn.addEventListener('click', () => {
    const s = trimStart * duration, e2 = trimEnd * duration;
    videoEl.currentTime = s;
    videoEl.muted = true;
    videoEl.play();
    playhead.style.display = 'block';
    const tick = () => {
      if (videoEl.paused) { playhead.style.display = 'none'; return; }
      if (videoEl.currentTime >= e2) { videoEl.pause(); playhead.style.display = 'none'; return; }
      playhead.style.left = (videoEl.currentTime / duration * 100) + '%';
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  });

  // ---- Conversion ----
  convertBtn.addEventListener('click', async () => {
    if (isConverting) return;
    isConverting = true;
    convertBtn.disabled = true;
    progressWrap.classList.add('active');
    resultPanel.classList.add('hidden');

    try {
      const fps = parseInt(fpsSelect.value);
      const maxW = parseInt(widthInput.value);
      const start = trimStart * duration, end = trimEnd * duration, clipDur = end - start;
      const vw = videoEl.videoWidth, vh = videoEl.videoHeight;
      const scale = Math.min(1, maxW / vw);
      const outW = Math.round(vw * scale), outH = Math.round(vh * scale);
      const canvas = document.createElement('canvas');
      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      const totalFrames = Math.ceil(clipDur * fps);
      const frameDelay = 1000 / fps;
      const encoder = new GIFEncoder(outW, outH);

      progressText.textContent = `Extracting frames (0/${totalFrames})...`;
      progressBar.style.width = '0%';

      for (let i = 0; i < totalFrames; i++) {
        await new Promise(resolve => {
          videoEl.currentTime = Math.min(start + i / fps, end);
          videoEl.addEventListener('seeked', () => {
            ctx.drawImage(videoEl, 0, 0, outW, outH);
            const px = new Uint8Array(ctx.getImageData(0, 0, outW, outH).data);
            encoder.addFrame(px, frameDelay);
            progressBar.style.width = Math.round(((i+1)/totalFrames) * 70) + '%';
            progressText.textContent = `Extracting frames (${i+1}/${totalFrames})...`;
            resolve();
          }, { once: true });
        });
      }

      progressText.textContent = 'Encoding GIF...';
      progressBar.style.width = '75%';
      await new Promise(r => setTimeout(r, 50));
      const bytes = encoder.encode();
      progressBar.style.width = '100%';

      gifBlob = new Blob([bytes], { type: 'image/gif' });
      resultImg.src = URL.createObjectURL(gifBlob);
      const sizeMB = (gifBlob.size / (1024*1024)).toFixed(2);
      resultMeta.textContent = `${outW}\u00D7${outH} \u00B7 ${totalFrames} frames \u00B7 ${fps} fps \u00B7 ${sizeMB} MB`;

      progressWrap.classList.remove('active');
      resultPanel.classList.remove('hidden');
    } catch (err) {
      console.error(err);
      progressText.textContent = 'Error: ' + err.message;
    } finally {
      isConverting = false;
      convertBtn.disabled = false;
    }
  });

  // ---- Download ----
  downloadBtn.addEventListener('click', () => {
    if (!gifBlob) return;
    const a = document.createElement('a');
    a.href = URL.createObjectURL(gifBlob);
    a.download = 'live-photo.gif';
    a.click();
  });

  // ---- Reset ----
  resetBtn.addEventListener('click', () => {
    editorPanel.classList.add('hidden');
    resultPanel.classList.add('hidden');
    dropZone.classList.remove('hidden');
    guide.classList.remove('hidden');
    hideStatus();
    videoEl.pause();
    videoEl.removeAttribute('src');
    fileInput.value = '';
    gifBlob = null;
    progressWrap.classList.remove('active');
  });
})();
</script>
</body>
</html>
